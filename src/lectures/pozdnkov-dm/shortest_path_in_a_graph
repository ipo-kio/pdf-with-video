\documentclass[russian]{lecture-notes}

\usepackage[final]{graphicx}
\usepackage{subcaption}
\usepackage{timestamps}
\usepackage{sectsty}
\sectionfont{\clearpage}
\usepackage{hyperref}
\usepackage{float}
\usepackage{amsmath}
\usepackage{cancel}
\usepackage{amssymb}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage{algpseudocode}

\renewcommand{\arraystretch}{1.3} %Для расстояния в таблицах
\cleartheorem{example*}
\theoremstyle{definition}
\newtheorem{example*}{Пример}[subsection]
\newtheorem*{exercise}{Упражнение}
\newcommand{\divs}{\mathrel{\raisebox{-2pt}{\vdots}}}
\DeclareMathOperator{\Aa}{A}
\newcommand{\A}[2]{\Aa(#1;#2)}
\DeclareMathOperator{\Dd}{D}
\newcommand{\D}[1]{\Dd(#1)}
\newcommand{\DD}[2]{\Dd(#1;#2)}
\DeclareMathOperator{\Bb}{B}
\newcommand{\B}[1]{\Bb(#1)}

\title{Лекция <<Построение кратчайших путей в графе>>}
\lecturer{Поздняков Сергей Николаевич}
\notesauthor{Кацер Евгений}
\date{21 декабря 2018 г.}
\youtubevideo{PkhLkx5EO9c}

\begin{document}
	\maketitle
	
	\begin{center}
		\section*{\LARGE\S 2 Построение кратчайших путей в графе}
		\timestamp{00:23}
		\label{par:krputi}
	\end{center}

	Эта задача является классической. Ее должны знать все, кто так или иначе связан с программированием или компьютерной математикой. Она интересна тем, что есть очень похожие задачи, имеющие разную сложность. Например, задача коммивояжера, заключающаяся в том, что нужно объехать N городов так, чтобы суммарный, путь или время были минимальные. Оказывается, эта задача относится к классу NP. Её можно решить перебирая все варианты (перебор всегда будет давать экспоненциальную трудоемкость по времени), в то время как проверить решение легко, правда, в определении класса NP проверка решения задачи должна давать ответ <<да>> или <<нет>>, поэтому, когда проверяют решение, ставят вопрос по-другому: не говорят, что <<является ли этот путь минимальным>>, а говорят, что <<верно ли, что построенный путь меньше такого-то числа>>. Поэтому здесь есть переход от классической постановки к немножко другой, эквивалентной исходной по трудоемкости.
	
	Другие задачи имеют эффективные алгоритмы. Мы сегодня рассмотрим три алгоритма, имеющие полиномиальную сложность: Форда-Беллмана, Дейкстры и Флойда. Они решают три задачи:
	\begin{enumerate}
		\item Найти кратчайший путь между двумя заданными вершинами.
		\item Найти длины кратчайших путей от заданной вершины до всех остальных.
		\item Найти кратчайшие пути между любыми парами вершин.
	\end{enumerate}

	То есть в одном случае две вершины фиксированы, во втором одна, а в третьем обе вершины не фиксированы. В каком порядке нужно решать эти задачи? Можно предположить, что сначала нужно решать первую, затем вторую и потом третью задачи, но это не лучший вариант.
	
	Как искать пути между двумя фиксированными вершинами? Если это просто путь, то это легко, но если нужно найти кратчайший путь, то как узнать, что выбранный путь кратчайший? 
	\begin{figure}[H]
		\centering
		\tikz{
			\path [thick, fill=black] (-1,1) circle (1mm);
			\path [thick, fill=black] (0,2) circle (1mm);
			\path [thick, fill=black] (-0.3,3) circle (1mm);
			\path [thick, fill=black] (1,3.3) circle (1mm);
			\path [thick, fill=black] (1,2.5) circle (1mm);
			\path [thick, fill=black] (2,1.5) circle (1mm);
			\path [thick, fill=black] (-2,1.5) circle (1mm);
			\path [thick, fill=black] (0,0) circle (1mm);
			\path [thick, fill=black] (1,0) circle (1mm);
			\path [thick, fill=black] (2,0.7) circle (1mm);
			\path [thick, fill=black] (1,0.7) circle (1mm);
			
			\draw [thick] (-2,1.5) -- (-1,1);
			\draw [thick] (-1,1) -- (0,2);
			\draw [thick] (0,2) -- (-0.3,3);
			\draw [thick] (-0.3,3) -- (1,3.3);
			\draw [thick] (1,3.3) -- (1,2.5);
			\draw [thick] (1,2.5) -- (2,1.5);
			\draw [thick] (-1,1) -- (0,0);
			\draw [thick] (0,0) -- (1,0);
			\draw [thick] (1,0) -- (1,0.7);
			\draw [thick] (1,0.7) -- (2,0.7);
			\draw [thick] (2,0.7) -- (2,1.5);
			
			\coordinate [label=left:$a$] (a) at (-2,1.5);
			\coordinate [label=right:$b$] (b) at (2,1.5);
			\coordinate [label=-100:$c$] (c) at (-1,1);
		}
		\caption{\small Пример двух путей из $a$ в $b$}
	\end{figure}
	Нам нужно сравнить его с длинами других путей, которые соединяют эти же две точки. Получается, решая первую задачу, мы все равно обращаемся ко второй или третьей, поэтому лучше начинать не с первой задачи, а со второй или третьей (трудоемкость обсуждаемых алгоритмов для них одинакова), однако решение третьей задачи требует большей памяти, так как нужно найти кратчайшие расстояния между всеми парами вершин, поэтому самый лучший вариант решения первой задачи~--- начинать со второй. 
	
	Для решения третьей задачи аналогично может возникнуть мысль использовать алгоритм для решения второй задачи, поставив его в цикл по всем вершинам. Этот путь неправильный, так как те алгоритмы, которые мы сегодня рассмотрим, имеют сложность $N^3$ или, как алгоритм Дейкстры, когда ребра неотрицательные~--- $N^2$, а лишний цикл увеличит показатель степени на единицу.
	
	\timestamp{06:04}
	Во всех алгоритмах будет следующая идея~--- идея последовательного улучшения пометки вершины, где пометка вершины на последнем шаге~--- это кратчайшее расстояние. Интересный вопрос <<какой смысл имеют пометки вершин на промежуточном шаге внешнего цикла>>. На этот вопрос студенты отвечают туманно: <<неточное кратчайшее расстояние>>, <<приближённое>> или <<почти кратчайшее>>. Это плохо, потому что, если мы не понимаем какой смысл имеют пометки на промежуточных шагах, то корректность алгоритма доказать аккуратно не сможем. Поэтому сегодня мы обязательно должны будем выяснить, какой смысл имеют эти пометки не на конечных, а на промежуточных шагах.
	
	Давайте рассмотрим задачу №2: допустим у нас есть вершина, которая называется источник ($S$). Мы будем искать кратчайшие пути до всех остальных вершин. Эти пути мы будем обозначать красным цветом:
	\begin{figure}[H]
		\centering
		\tikz{
			\draw (-3,0) -- (-1.5,0);
			\draw [dashed] (-1.5,0) -- (0,0);
			\draw [dashed] (0,0) -- (1.5,0);
			\draw [dashed] (1.5,0) -- (3,0);
			
			\draw [red] (-3,0) arc (180:0:3 and 1.5);
			\draw [dashed]  (-1.5,0) arc (180:0:2.25 and 1);
			\draw [dashed]  (0,0) arc (180:0:1.5 and 0.5);
			
			\path [draw=black, fill=white] (-3,0) circle (1mm);
			\path [draw=black, fill=white] (-1.5,0) circle (1mm);
			\path [draw=black, fill=white] (0,0) circle (1mm);
			\path [draw=black, fill=white] (1.5,0) circle (1mm);
			\path [draw=black, fill=white] (3,0) circle (1mm);
			
			\coordinate [label=left:$s$] (1) at (-3,0);
			\coordinate [label=right:$v$] (2) at (3,0);
		}
		\caption{\small Задача №2}
	\end{figure}
	
	Рассмотрим идею на примере пошагового увеличения числа ребер в пути. На первом шаге найти длины кратчайших путей, состоящих из одного ребра, легко~--- это будут длины ребер. Рассмотрим, как будет меняться ситуация, если, кроме путей из одного ребра, рассматривать также пути из двух ребер, потом к ним добавим пути из трех рёбер и т.д.
	\begin{figure}[H]
		\centering
		\tikz{
			\draw [red] (-3,0) -- (-1.5,0);
			\draw (-1.5,0) -- (0,0);
			\draw [dashed] (0,0) -- (1.5,0);
			\draw [dashed] (1.5,0) -- (3,0);
			
			\draw (-3,0) arc (180:0:3 and 1.5);
			\draw [red]  (-1.5,0) arc (180:0:2.25 and 1);
			\draw [dashed]  (0,0) arc (180:0:1.5 and 0.5);
			
			\path [draw=black, fill=white] (-3,0) circle (1mm);
			\path [draw=black, fill=white] (-1.5,0) circle (1mm);
			\path [draw=black, fill=white] (0,0) circle (1mm);
			\path [draw=black, fill=white] (1.5,0) circle (1mm);
			\path [draw=black, fill=white] (3,0) circle (1mm);
			
			\coordinate [label=left:$s$] (1) at (-3,0);
			\coordinate [label=right:$v$] (2) at (3,0);
		}
		\caption{\small После добавления двух новых ребер}
	\end{figure}
	
	 Например, на третьем шаге путь уже может состоять не из одного, а из двух или трех ребер. Может быть, он будет короче, чем найденный ранее? Нужно их сравнить. Если первый оказался короче (рисунок 2), то он и остается, а если второй (рисунок 3), то будем считать его самым коротким. Затем добавим еще ребер:
	 \begin{figure}[H]
	 	\centering
	 	\tikz{
	 		\draw [red] (-3,0) -- (-1.5,0);
	 		\draw [red] (-1.5,0) -- (0,0);
	 		\draw (0,0) -- (1.5,0);
	 		\draw [dashed] (1.5,0) -- (3,0);
	 		
	 		\draw (-3,0) arc (180:0:3 and 1.5);
	 		\draw (-1.5,0) arc (180:0:2.25 and 1);
	 		\draw [red] (0,0) arc (180:0:1.5 and 0.5);
	 		
	 		\path [draw=black, fill=white] (-3,0) circle (1mm);
	 		\path [draw=black, fill=white] (-1.5,0) circle (1mm);
	 		\path [draw=black, fill=white] (0,0) circle (1mm);
	 		\path [draw=black, fill=white] (1.5,0) circle (1mm);
	 		\path [draw=black, fill=white] (3,0) circle (1mm);
	 		
	 		\coordinate [label=left:$s$] (1) at (-3,0);
	 		\coordinate [label=right:$v$] (2) at (3,0);
	 	}
	 	\caption{\small После добавления еще двух новых ребер}
	 \end{figure}
 
 	И так далее на каждом шаге будем добавлять в пути по одному новому ребру и сравнивать пути:
 	\begin{figure}[H]
 		\centering
 		\tikz{
 			\draw [red] (-3,0) -- (-1.5,0);
 			\draw [red] (-1.5,0) -- (0,0);
 			\draw [red](0,0) -- (1.5,0);
 			\draw [red] (1.5,0) -- (3,0);
 			
 			\draw (-3,0) arc (180:0:3 and 1.5);
 			\draw (-1.5,0) arc (180:0:2.25 and 1);
 			\draw (0,0) arc (180:0:1.5 and 0.5);
 			
 			\path [draw=black, fill=white] (-3,0) circle (1mm);
 			\path [draw=black, fill=white] (-1.5,0) circle (1mm);
 			\path [draw=black, fill=white] (0,0) circle (1mm);
 			\path [draw=black, fill=white] (1.5,0) circle (1mm);
 			\path [draw=black, fill=white] (3,0) circle (1mm);
 			
 			\coordinate [label=left:$s$] (1) at (-3,0);
 			\coordinate [label=right:$v$] (2) at (3,0);
 		}
 		\caption{\small После добавления еще двух новых ребер}
 	\end{figure}
 	
 	Когда мы добавляем новое ребро, мы уже имеем предыдущее кратчайшее расстояние $\D{v}$ (по путям из меньшего количества рёбер). Рассмотрим все вершины, из которых можно попасть в вершину $v$:
 	\begin{figure}[H]
 		\centering
 		\tikz{
 			\draw (-3,0) -- (-1.5,-1);
 			\draw (-3,0) -- (-0.25,-0.2);
 			\draw (-3,0) -- (-2,1.4);
 			\draw (-1.5,-1) -- (0.5,-0.5);
 			\draw (-0.25,-0.2) -- (0.5,-0.5);
 			\draw (0.5,-0.5) -- (1.4,-0.4);
 			\draw (0.5,-0.5) -- (2,-1);
 			\draw (-2,1.4) -- (-0.25,-0.2);
 			\draw (-2,1.4) -- (-0.4,1);
 			\draw (-0.4,1) -- (-0.25,-0.2);
 			\draw (-0.4,1) -- (1,1.75);
 			\draw (-0.25,-0.2) -- (0.7,1.25);
 			\draw (0.7,1.25) -- (1,1.75);
 			\draw (0.7,1.25) -- (1.4,-0.35);
 			
 			\draw [dashed] (2,-1) -- (3,0.3);
 			\draw [dashed] (1.4,-0.4) -- (3,0.3);
 			\draw [dashed] (1,1.75) -- (3,0.3);
 			\draw [dashed] (0.7,1.25) -- (3,0.3);
 			
 			\path [draw=black, fill=white] (-3,0) circle (1.25mm);
 			\path [draw=black, fill=white] (3,0.3) circle (1.25mm);
 			\path [draw=black, fill=white] (2,-1) circle (1.25mm);
 			\path [draw=black, fill=white] (-1.5,-1) circle (1.25mm);
 			\path [draw=black, fill=white] (0.5,-0.5) circle (1.25mm);
 			\path [draw=black, fill=white] (1.4,-0.4) circle (1.25mm);
 			\path [draw=black, fill=white] (-0.25,-0.2) circle (1.25mm);
 			\path [draw=black, fill=white] (-2,1.4) circle (1.25mm);
 			\path [draw=black, fill=white] (-0.4,1) circle (1.25mm);
 			\path [draw=black, fill=white] (0.7,1.25) circle (1.25mm);
 			\path [draw=black, fill=white] (1,1.75) circle (1.25mm);
 			
 			\coordinate [label=left:$s$] (1) at (-3.05,0);
 			\coordinate [label=right:$v$] (2) at (3.05,0.3);
 			\coordinate [label=below:$w$] (3) at (2,-1.05);
 			\coordinate [label=45:$w$] (4) at (1.25,-0.35);
 			\coordinate [label=-135:$w$] (5) at (0.7,1.375);
 			\coordinate [label=above:$w$] (6) at (1,1.8);
 		}
 		\caption{\small Модификация пометки в вершине $v$}
 	\end{figure}
 
 	Такие вершины обозначим $w$ (рис. 6). Путь до $w$ будет иметь на одно ребро меньше, чем до $v$, а для путей не более чем с таким количеством рёбер кратчайшее расстояние до вершин уже известно. Теперь рассмотрим длины рёбер от вершин $w$ до $v$, которые обозначим $\A{w}{v}$. Мы можем сравнить суммы из кратчайших расстояний до $w$ (по путям с количеством ребер на 1 меньше рассматриваемых) с длинами этих рёбер и взять минимальное значение из вновь рассмотренных путей и тех. что были построены на предыдущем шаге (первая пометка соответствует путям с количеством ребер на одно меньше, вторая~--- путям после добавления одного нового ребра):
 	\[
 		\min_w(\D{v};\D{w} + \A{w}{v})
 	\]
 	$\D{w} + \A{w}{v}$ означает, что мы прошли до предыдущей вершины и прибавили к её пометке длину последнего в пути ребра. Минимум по всем вершинам $w$, по которым можно сюда попасть. Получится, что на каждом шаге будет добавляться одно ребро. В качестве начальных пометок нужно взять длины ребер. Если из $s$ в $v$ есть ребро, это и будет инициализация этой пометки. На каждом шаге мы будем пометку менять следующим способом:
 	\[
 		\D{v} := \min_w(\D{v};\D{w} + \A{w}{v})
 	\]
 	
 	\timestamp{10:21}
 	Сколько надо сделать таких шагов, если у нас на начальном, нулевом шаге инициализации уже даны расстояния по путям из одного ребра, то есть, длины рёбер? Иными словами, сколько раз нужно повторить процедуру наращивания рёбер, чтобы убедиться, что найдены кратчайшие пути? Если в графе $N$ вершин, то в худшем случае кратчайший путь будет содержать $N-1$ ребро (если самый короткий путь проходит через все вершины). Так как у нас уже есть расстояние из одного ребра, то нам нужно повторить эту процедуру $N-2$ раза. Это и есть \emph{алгоритм Форда-Беллмана}. Сейчас мы его аккуратно запишем, но перед этим попробуем ответить на такой вопрос: может ли кратчайший путь состоять более чем из $N-1$ ребра? Нарисуем картинку (граф может быть как ориентированный, так и неориентированный, в отличие от остовных деревьев):
 	\begin{figure}[H]
 		\centering
 		\tikz{
 			\draw [thick, ->] (-3,0) -- (-0.3,0);
 			\draw [thick, ->] (0,0) -- (2.7,0);
 			\draw [thick, ->] (0,0) -- (1.288,-1.788);
 			\draw [thick, <-] (-0.212,-0.212) -- (-1.5,-2);
 			\draw [thick, <-] (-1.2,-2) -- (1.5,-2);
 			
 			\path [draw=black, fill=white, thick] (0,0) circle (3mm);
 			\path [draw=black, fill=white, thick] (-3,0) circle (3mm);
 			\path [draw=black, fill=white, thick] (3,0) circle (3mm);
 			\path [draw=black, fill=white, thick] (-1.5,-2) circle (3mm);
 			\path [draw=black, fill=white, thick] (1.5,-2) circle (3mm);
 			
 			\coordinate [label=above:$b$] (1) at (0,0.3);
 			\coordinate [label=above:$a$] (2) at (-3,0.3);
 			\coordinate [label=above:$c$] (3) at (3,0.3);
 			\coordinate [label=below:$d$] (4) at (1.5,-2.3);
 			\coordinate [label=below:$e$] (5) at (-1.5,-2.3);
 			
 			\coordinate [label=above:$1$] (6) at (-1.5,0);
 			\coordinate [label=above:$2$] (7) at (1.5,0);
 			\coordinate [label=below:$-2$] (8) at (0,-2);
 			\coordinate [label=left:$-2$] (9) at (-0.77,-0.98);
 			\coordinate [label=right:$3$] (10) at (0.75,-1);
 		}
 		\caption{\small Граф, у которого нет кратчайшего пути от $a$ до $c$}
 	\end{figure}
 
 	\begin{note}
 		Если путь без стрелок, значит они есть в две стороны.
  	\end{note}
  
  	У этого графа нет кратчайшего пути, потому что, если мы идем напрямую, получаем 3, если сделаем один круг, получим два, если сделаем два круга, получим один и так далее. У алгоритма Форда-Беллмана есть естественное ограничение на применение, если нет кратчайшего пути, то алгоритм работать не будет, поэтому нужно исключить один случай~--- циклы отрицательной длины.
  	
  	Применимость этого алгоритма~--- ориентированные или неориентированные графы. Они даже могут быть несвязные, тогда расстояние до некоторых вершин будет бесконечным, если в них попасть нельзя.
  	
  	Пусть у нас есть граф ориентированный или неориентированный, взвешенный, с, возможно, отрицательными ребрами, но без циклов отрицательной длины. Напишем следующий алгоритм и докажем его корректность:
  	\timestamp{15:00}
  	\begin{algorithm}[H]
  		\caption{Алгоритм Форда-Беллмана}
  		\label{alg:ford}
  		\begin{algorithmic}[1]
  			\State Инициализация:
  			\ForAll{$v \in V$}
  			\Comment{$V$~--- множество всех вершин}
  			\State $\D{v}:=\A{s}{v}$
  			\Comment{Пометка~--- это ребро, соединяющее $s$ и $v$}
  			\EndFor
  			\State $s$~--- источник, из которого мы ищем пути
  			\State $\A{s}{v}$~--- длина ребра $(s;v)$
  			\Statex
  			\State Основной цикл:
  			\For{$i$ от $1$ до $N-2$}
  			\Comment{$|V| = N$~--- число вершин}
  			\State Эту процедуру мы должны повторить для каждой вершины $v$ и для каждой промежуточной вершины $w$. Здесь в зависимости от того, как у вас представлен граф, можно делать либо грубый, либо красивый алгоритм. 
  			
  			Грубый алгоритм~--- это просто два цикла по всем вершинам. Его нужно применять, когда мы работаем с матрицами смежности.
  			
  			Если у нас граф представлен списками смежности, то есть, мы для каждой вершины знаем соседей, то можно рассматривать только соседей вершины.
  			\ForAll{$v \in V$}
  			\ForAll{$w \in V$}
  			\Comment{Можно брать только соседей $v$}
  			\State $\D{v} := \min(\D{v};\D{w} + \A{w}{v})$
  			\EndFor
  			\EndFor
  			\EndFor
  		\end{algorithmic}
  	\end{algorithm}
  	
  	\begin{note}
  		Алгоритм Форда-Беллмана решает задачу №2.
  	\end{note}
  
  	
  	Теперь мы ответим на вопрос из начала лекции: какой смысл имеет пометка, допустим, на $k$-ом шаге внешнего цикла (который повторяется $N-2$ раза)? \emph{Пометка}~--- это кратчайшее расстояние, но не абсолютно кратчайшее, а по путям, у которых количество ребер не более $k$. То есть, когда мы сделали инициализацию, то пометки~--- кратчайшие расстояния по путям из одного ребра. Когда мы выполним тело цикла один раз, пометки уже будут соответствовать кратчайшим расстояниям по путям из двух (или одного) рёбер. Заметим, что в алгоритме рассматриваются кратчайшие расстояния по путям, состоящим не более чем из $k$ ребер, а не ровно из $k$ ребер, так как может остаться путь из меньшего числа рёбер короче и увеличение числа рёбер в пути не приводит к уменьшению его длины.
  
  	Докажем корректность алгоритма: для этого докажем лемму:
  
	\begin{lemma}
		\timestamp{22:13}
	  	Смысл пометки $\D{v}$ на $k$-ом шаге внешнего цикла следующий~--- это кратчайшее расстояние от источника до вершины $v$ по всем путям, состоящим из не более чем $k$ ребер.
  	\end{lemma}
	  
	\begin{note}
  		Иначе эту лемму можно назвать леммой об \emph{инварианте цикла} (инвариант цикла ~--- это утверждение, точнее предикат~--- утверждение с переменными, которое остается верным как до, так и после выполнения тела цикла, то есть остаётся истинным в процессе выполнения алгоритма, несмотря на то, что зависит от $k$).
  	\end{note}
  
  	\begin{proof}
  		Будем доказывать по индукции.
  		
  		База индукции: пусть $k = 1$. Инициализация алгоритма сделана так, чтобы обеспечить базу индукции. Мы написали явно, что расстояние по путям из одного ребра~--- это длина ребра. Инициализация очевидно обеспечивает корректность этого условия (фактически, инициализация~--- есть база индукции).
  		
  		\begin{note}
  			Правильно написанная программа доказывает сама себя. Чтобы база индукции была выполнена, нужно позаботиться, чтобы изначально в алгоритме условие было выполнено.
  		\end{note}
  		
  		Индукционный переход: пусть после выполнения $k$ шагов утверждение истинно. Докажем, что оно будет выполняться и после выполнения $k+1$ шага. Это условие обеспечивается операциями в теле цикла.
  		
  		Любой путь из $k+1$ ребра состоит из последнего ребра и пути, у которого на одно ребро меньше. Следовательно, если мы рассмотрим все входящие в эту вершину рёбра и сравним длины путей, состоящих из путей, которые рассматривались на предыдущем шаге, и еще одного ребра с пометками, которые были найдены на предыдущем шаге, мы и получим кратчайшее расстояние по путям с количеством ребер $k+1$ или меньше. Таким образом, действие $\D{v} := \min(\D{v};\D{w} + \A{w}{v})$ - это в явном виде обеспечение индукционного перехода. Мы специально нарастили одно ребро (раньше было $k$ ребер, теперь $k+1$). Поскольку других путей нет, после выполнения этого шага будут рассмотрены все пути из $k+1$ ребра.
  		
  	\end{proof}
  
  	Мы доказали лемму, теперь осталось доказать теорему. Мы уже говорили, что максимальное количество ребер в пути графа, который не содержит циклов отрицательной длины, будет $N-1$. При инициализации путь уже состоит из одного ребра. Потом мы повторили наращивание ребер в пути $N-2$ раза. После выполнения алгоритма по лемме будет получено, что пометка дает нам кратчайшее расстояние по всем путям с числом ребер не более $N-1$, а это и есть кратчайшее расстояние вообще, если нет циклов отрицательной длины. \textbf{Теорема доказана.}
  	
  	\timestamp{29:01}
  	Следующий алгоритм, который мы рассмотрим, называется \emph{алгоритмом Дейкстры}. Он отличается от алгоритма Форда-Беллмана тем, что все ребра имеют неотрицательную длину.
  	
  	\begin{note}
  		Мы говорили на лекции о том, что от минуса иногда выгодно избавиться. В алгоритме Дейкстры мы избавились от отрицательных рёбер и сразу же получили выигрыш в эффективности. В алгоритме Форда-Беллмана для решения нам потребуется $N^3$ шагов, так как там тройной цикл и каждый из них примерно $N$ шагов, в алгоритме Дейкстры нам нужно $N^2$ шагов.
  	\end{note}
  
  	Идея алгоритма Дейкстры состоит в следующем: первый шаг будет такой же, как в алгоритме Форда-Беллмана. Мы рассмотрим все ребра, исходящие из вершины $S$, и выберем из них минимальное. Первая пометка вершины, которая является минимальной, даст нам минимальный путь:
  	\begin{figure}[H]
  		\centering
  		\tikz{
  			\draw (0,0) -- (0,1.5);
  			\draw (0,0) -- (-2,1.5);
  			\draw (0,0) -- (2,1.5);
  			\foreach \x in {0.2,0.35,...,1.4} \draw (-0.1,\x) -- (0.1,\x);
  			
  			\path [draw=black] (0,1.5) circle (3mm);
  			\path [draw=black, fill=white] (0,0) circle (1mm);
  			\path [draw=black, fill=white] (0,1.5) circle (1mm);
  			\path [draw=black, fill=white] (-2,1.5) circle (1mm);
  			\path [draw=black, fill=white] (2,1.5) circle (1mm);
  			
  			\coordinate [label=below:$s$] (1) at (0,-0.1);
  		}
  		\caption{\small Иллюстрация начала работы алгоритма Дейкстры}
  	\end{figure}
  
  	Пусть путь до обведенной вершины наименьший. Может ли быть более короткий путь до этой вершины? Чтобы пойти более коротким путем, мы должны пойти по другому ребру, но выбранное ребро самое маленькое, значит, если мы придём по другому пути в эту вершину, мы по крайней мере пройдём по одному ребру, которое больше либо равно наименьшему. И еще нам придется пройти по другому ребру, длина которого тоже больше либо равна нулю, то есть за счёт другого ребра уменьшить путь не удастся. Поэтому на первом шаге мы получим самый короткий путь до одной из вершин.
  	
  	Дальше многие студенты думают, что надо этот путь наращивать, идти по пути, проходящем через первую найденную вершину. Это совсем не обязательно. Может оказаться, что пути до других вершин окажутся самыми короткими, но не будут проходить через эту вершину: 
  	\begin{figure}[H]
  		\centering
  		\tikz{
  			\draw (0,0) -- (0,1.5);
  			\draw (0,0) -- (-2,1.5);
  			\draw (0,0) -- (2,1.5);
  			\foreach \x in {0.2,0.35,...,1.4} \draw (-0.1,\x) -- (0.1,\x);
  			\draw (0,1.5) -- (2,1.5);
  			
  			\path [draw=black] (0,1.5) circle (3mm);
  			\path [draw=black, fill=white] (0,0) circle (1mm);
  			\path [draw=black, fill=white] (0,1.5) circle (1mm);
  			\path [draw=black, fill=white] (-2,1.5) circle (1mm);
  			\path [draw=black, fill=white] (2,1.5) circle (1mm);
  			
  			\coordinate [label=below:$s$] (1) at (0,-0.1);
  			\coordinate [label=above:$a$] (2) at (0,1.7);
  			\coordinate [label=above:$b$] (3) at (2,1.7);
  		}
  	\end{figure}
  	
  	Действительно, не обязательно, чтобы попасть в вершину $b$, надо идти через вершину $a$, может быть, путь прямо в $b$ будет короче. Поэтому мы создаем множество, называемое фронтом, состоящее из вершин, которые будут рассматриваться (соседние вершины с теми, до которых кратчайшее расстояние найдено) и будем вычислять пометки по аналогии с алгоритмом Форда-Беллмана: к уже найденным пометкам добавляем длины рёбер в соседние вершины и вычисляем минимальное значение:
  	\begin{figure}[H]
  		\centering
  		\tikz{
  			\draw (0,0) -- (-2,1.5);
  			\draw (0,0) -- (2,1.5);
  			\draw (0,0) -- (0,1.5);
  			\foreach \x in {0.2,0.35,...,1.4} \draw (-0.1,\x) -- (0.1,\x);
  			\draw (0,1.5) -- (-0.5,2);
  			\draw (0,1.5) -- (0.5,2);
  			\draw (0,1.5) -- (0,2.3);
  			\draw (-0.4,1.7) arc (140:40:0.5) -- (2,1.3) arc (-90:80:0.3) -- (0.2,2.5) arc (30:150:0.225 and 0.1) -- (-2,1.9) arc (100:270:0.3) -- cycle;
  			
  			\path [draw=black] (0,1.5) circle (3mm);
  			\path [draw=black, fill=white] (0,0) circle (1mm);
  			\path [draw=black, fill=white] (0,1.5) circle (1mm);
  			\path [draw=black, fill=white] (-2,1.5) circle (1mm);
  			\path [draw=black, fill=white] (2,1.5) circle (1mm);
  			\path [draw=black, fill=white] (0.5,2) circle (1mm);
  			\path [draw=black, fill=white] (-0.5,2) circle (1mm);
  			\path [draw=black, fill=white] (0,2.3) circle (1mm);
  			
  			\coordinate [label=below:$s$] (1) at (0,-0.1);
  			\coordinate [label=left:$c$] (2) at (-0.55,2);
  			\coordinate [label=above:$d$] (3) at (0,2.45);
  			\coordinate [label=right:$e$] (4) at (0.55,2);
  			\coordinate [label=-135:$a$] (5) at (-0.15,1.6);
  		}
  		\caption{\small Второй шаг работы алгоритма Дейкстры}
  	\end{figure}
  
  	Эту процедуру мы будем повторять. На каждом шаге у нас будет находиться еще одна вершина, для которой минимальное расстояние известно.
  	
  	А какой смысл будет у пометок остальных (ещё не обработанных) вершин? Это будут кратчайшие пути, обладающие таким свойством: все вершины кроме последней обработаны. То есть кратчайший путь до предпоследней вершины найден, а они являются соседними с ней (например, путь до $a$ найден, а $c$, $d$ и $e$~--- ее соседи). Если по таким путям до вершин добраться нельзя, то пометкой будет <<бесконечность>> (достаточно большое число). Давайте рассмотрим теперь сам алгоритм (инициализация в точности как у алгоритма Форда-Беллмана):
  	\timestamp{33:59}
  	\begin{algorithm}[H]
  		\caption{Алгоритм Дейкстры}
  		\label{alg:deyk}
  		\begin{algorithmic}[1]
  			\State Инициализация:
  			\ForAll{$v \in V$}
  			\State $\D{v}:=\A{s}{v}$
  			\EndFor
  			\State $V'$~--- множество обработанных вершин, то есть тех, до которых расстояние уже найдено
  			\State $V/V'$~--- множество необработанных вершин
  			\State Мы будем продолжать цикл, пока множество необработанных вершин не пусто. После завершения цикла все вершины будут обработаны, то есть до всех них кратчайшие расстояния найдены.
  			\State $V' = \{s\}$
  			\Comment{множество обработанных вершин в начале состоит только из источника, до которого  расстояние равно нулю}
  			\Statex
  			\State Основной цикл:
  			\While{$V/V' \ne 0$}
  			\Comment{Пока есть необработанные вершины}
  			\State Найти вершину с минимальной пометкой $\D{v}$
  			\State
  			\Comment{Для этого мы должны просмотреть все вершины}
  			\Statex
  			\State $V' := V' \bigcup \{v\}$
  			\State Теперь мы модифицируем пометки, добавляя те вершины, которые являются соседними к $v$ (на рисунке 8 роль $v$ играет $a$, а вершины, находящиеся в выделенной области~--- соседи. Обозначим их через $w$).
  			\ForAll{$w \in V$}
  			\Comment{По соседям $v$ будет быстрее}
  			\State $\D{w} = \min(\D{w};\D{w} + \A{v}{w})$
  			\EndFor
  			\EndWhile
  		\end{algorithmic}
  	\end{algorithm}
  
  	Можно заметить, что у нас основной цикл имеет $N$ шагов, а вложенный в него цикл менее $N$ шагов, поэтому сложность будет порядка $N^2$, что делает его быстрее алгоритма Форда-Беллмана.
  	
  	Докажем корректность алгоритма Дейкстры. Для этого сформулируем лемму:
  	\begin{lemma}
  		\timestamp{40:24}
  		На $k$-ом шаге внешнего цикла пометка $\D{v}$ имеет следующий смысл:
  		\begin{enumerate}
  			\item Для обработанных вершин это кратчайшее расстояние до источника.
  			\item Для необработанных вершин~--- это кратчайшее расстояние до источника по путям, у которых все вершины кроме последней обработаны.
  		\end{enumerate}
  	\end{lemma}
  
  	\begin{proof}
  		Докажем по индукции.
  		
  		База индукции: обеспечивается инициализацией. Если мы берем кратчайшее из ребер, которое выходит из вершины, то более короткого пути уже не будет. 
  		
  		Индукционный переход: предположим, что после выполнения $k$ шагов цикла условие выполняется и докажем, что после выполнения $k+1$ шага условие тоже будет выполняться.
  		
  		Докажем, что после очередного выполнения цикла у нас добавится еще одна вершина, для которой кратчайшее расстояние найдено. 
  		
  		От противного: пусть $\D{v}$ на $k+1$ шаге не является кратчайшим. Как мы получили минимальное из пометок, которые были на предыдущем шаге? У нас есть какое-то множество пометок на $k+1$ шаге и мы выбрали минимальную из пометок (минимальным является не ребро, а путь до источника):
  		\begin{figure}[H]
  			\centering
  			\tikz{
  				\draw (-0.75,0) -- (0,0.75);
  				\draw (0,0.75) -- (0,1.5);
  				\draw (0,0.75) -- (-1.8,1.6);
  				\draw (0,0.75) -- (1.8,1.6);
  				\draw (0,1.5) -- (-0.75,2);
  				\draw (0,1.5) -- (0.75,2);
  				\draw (0,1.5) -- (0,2.3);
  				\draw (-0.4,1.7) arc (140:40:0.5) -- (2,1.3) arc (-90:80:0.3) -- (0.2,2.5) arc (30:150:0.225 and 0.1) -- (-2,1.9) arc (100:270:0.3) -- cycle;
  				
  				\foreach \x in {1.65,1.75,...,2.25} \draw (-0.1,\x) -- (0.1,\x);
  				\foreach \x in {0.9,1,...,1.4} \draw (-0.1,\x) -- (0.1,\x);
  				\foreach \x in {0.15,0.25,...,0.7} \draw (-0.85+\x,\x) -- (-0.65+\x,\x);
  				
  				\path [draw=black, fill=white] (-0.75,0) circle (1mm);
  				\path [draw=black, fill=white] (0,0.75) circle (1mm);
  				\path [draw=black, fill=white] (-1.8,1.6) circle (1mm);
  				\path [draw=black, fill=white] (1.8,1.6) circle (1mm);
  				\path [draw=black, fill=white] (0,1.5) circle (1mm);
  				\path [draw=black, fill=white] (-0.75,2) circle (1mm);
  				\path [draw=black, fill=white] (0.75,2) circle (1mm);
  				\path [fill=black] (0,2.3) circle (1mm);
  				
  				\coordinate [label=right:$k+1$] (1) at (2.2,2); 				
  			}
  			\caption{\small Минимальный путь выделен штриховкой}
  		\end{figure}
  		
  		Пусть есть какой-то путь до какой-нибудь вершины, который короче заштрихованного. Этот путь обязательно должен пройти через какую-то вершину, которая является последней из необработанных:
  		\begin{figure}[H]
  			\centering
  			\tikz{
  				\draw (-0.75,0) -- (0,0.75);
  				\draw (0,0.75) -- (0,1.5);
  				\draw (0,0.75) -- (-1.8,1.6);
  				\draw (0,0.75) -- (1.8,1.6);
  				\draw (0,1.5) -- (-0.75,2);
  				\draw (0,1.5) -- (0.75,2);
  				\draw (0,1.5) -- (0,2.3);
  				\draw (-0.4,1.7) arc (140:40:0.5) -- (2,1.3) arc (-90:80:0.3) -- (0.2,2.5) arc (30:150:0.225 and 0.1) -- (-2,1.9) arc (100:270:0.3) -- cycle;
  				\draw [dashed] (-1.8,1.6) -- (-1.8,2.3);
  				\draw [dashed] (-1.8,2.3) -- (-2.5,3);
  				
  				\foreach \x in {1.65,1.75,...,2.25} \draw (-0.1,\x) -- (0.1,\x);
  				\foreach \x in {0.9,1,...,1.4} \draw (-0.1,\x) -- (0.1,\x);
  				\foreach \x in {0.15,0.25,...,0.7} \draw (-0.85+\x,\x) -- (-0.65+\x,\x);
  				
  				\path [draw=black, fill=white] (-0.75,0) circle (1mm);
  				\path [draw=black, fill=white] (0,0.75) circle (1mm);
  				\path [draw=black, fill=white] (-1.8,1.6) circle (1mm);
  				\path [draw=black, fill=white] (1.8,1.6) circle (1mm);
  				\path [draw=black, fill=white] (0,1.5) circle (1mm);
  				\path [draw=black, fill=white] (-0.75,2) circle (1mm);
  				\path [draw=black, fill=white] (0.75,2) circle (1mm);
  				\path [fill=black] (0,2.3) circle (1mm);
  				\path [draw=black, fill=white] (-1.8,2.3) circle (1mm);
  				\path [draw=black, fill=white] (-2.5,3) circle (1mm);
  				
  				\coordinate [label=right:$k+1$] (1) at (2.2,2);
  				\coordinate [label=above:$\D{v}$] (2) at (0,2.45);
  				\coordinate [label=below:$w'$] (3) at (-1.8,1.4);
  				\coordinate [label=left:$w''$] (4) at (-2.5,3);
  			}
  			\caption{\small Новый более короткий путь}
  		\end{figure}
  	
  		Пометка $\D{w'}$ не может быть меньше пометки $\D{v}$, в худшем случае она равна этой пометке ($\D{w'} \geqslant \D{v}$). Если бы она была меньше, мы бы её и выбрали, а $\D{w''}$ не может быть меньше пометки $\D{w'}$ ($\D{w''} \geqslant \D{w'}$), так как добавляются ребра неотрицательной длины, следовательно, $\D{w''} \geqslant \D{v}$~--- противоречие!!!
  		
  		Второе условие (для необработанных вершин) обеспечивается искусственно в алгоритме (мы просто добавляем все соседние вершины к обработанной).
  		
  	\end{proof}
  
  	\timestamp{46:54}
  	Можно заметить, что схема похожая: инициализацией мы обеспечиваем базу индукции, а телом основного цикла~--- индукционный переход.
  	
  	Третий алгоритм~--- алгоритм Флойда. Этот алгоритм, в отличие от двух предыдущих, решает задачу №3. Он находит расстояния между всеми парами вершин. Ранее мы изучали алгоритм Уоршелла~--- алгоритм транзитивного замыкания. Так вот это один и тот же алгоритм, только алгоритм транзитивного замыкания применим к невзвешенным графам, а в алгоритме Флойда мы добавили еще веса. Алгоритм Флойда состоит из трёх циклов. Пометка теперь нам нужна не от одной переменной, а от двух, потому что теперь \emph{пометка} - это кратчайшее расстояние от вершины $u$ до вершины $v$ (на некотором подмножестве путей), поэтому инициализация будет длинами всех ребер:
  	\begin{algorithm}[H]
  		\caption{Алгоритм Флойда}
  		\label{alg:floyd}
  		\begin{algorithmic}[1]
  			\State Инициализация:
  			\ForAll{$u \in V$}
  			\ForAll{$v \in V$}
  			\State $\DD{u}{v} := \A{u}{v}$
  			\Comment{Если ребра нет, то пометка будет бесконечной}
  			\EndFor
  			\EndFor
  			\Statex
  			\State Основной цикл:
  			\ForAll{$w \in V$}
  			\Comment{Идет по промежуточной вершине}
  			\ForAll{$u \in V$}
  			\ForAll{$v \in V$}
  			\Comment{Эти два идут по парам вершин, между которыми мы ищем кратчайшие пути}
  			\State $\DD{u}{v} := \min(\DD{u}{v};\DD{u}{w} + \DD{w}{v})$
  			\EndFor
  			\EndFor
  			\EndFor
  		\end{algorithmic}
  	\end{algorithm}
  
  	Поясним картинкой:
  	\begin{figure}[H]
  		\centering
  		\tikz{
  			\draw (-2,0) -- (-1,-1) -- (-0.5,-0.5);
  			\draw [dashed] (-0.5,-0.5) -- (0,-1.25);
  			\draw (0,-1.25) -- (0.5,-1) -- (1,-1.25) -- (1.25,-0.75) -- (1.5,-1) -- (1.75,-0.4) -- (1.85,-0.5);
  			\draw [dashed] (1.85,-0.5) -- (2,0);
  			\draw (-2,0) -- (-0.5,0.5) -- (0.5,0.5);
  			\draw [dashed] (0.5,0.5) -- (1,0.3);
  			\draw (1,0.3) -- (1.5,0.7) -- (2,0);
  			
  			\path [draw=black, fill=white] (-2,0) circle (1.25mm);
  			\path [draw=black, fill=white] (2,0) circle (1.25mm);
  			\path [draw=black, fill=white] (0.5,-1) circle (1.25mm);
  			
  			\coordinate [label=left:$u$] (1) at (-2,0);
  			\coordinate [label=below:$w$] (2) at (0.5,-1.05);
  			\coordinate [label=right:$v$] (3) at (2,0);
  		}
  		\caption{\small Пример путей с промежуточной вершиной $w$ и без нее}
  	\end{figure}
  
	Мы можем сравнить вариант пути, когда мы вершину $w$ не используем и идём от $u$ до $v$, либо когда мы идем через $w$: сначала доходим до $w$, потом до $v$. Здесь очень интересно спросить вас, как вы считаете, что будет инвариантом этого цикла? То есть, если мы по внешнему циклу сделаем $k$ шагов, какой смысл будут иметь пометки?
	
	Давайте упростим вопрос: сделаем один шаг. До выполнения цикла у нас пометки~--- это длины кратчайших путей напрямую, когда промежуточных вершин нет. Когда мы выполним один раз тело внешнего цикла, то будут рассмотрены все пути через одну (первую по порядку выбора) вершину:
	\begin{figure}[H]
		\centering
		\tikz{
			\draw [->] (-2,1) -- (1.85,1);
			\draw [->] (-2,-1) -- (1.85,-1);
			\draw [->] (0,0) -- (1.87,0.93);
			\draw [->] (0,0) -- (1.87,-0.93);
			\draw [->] (-2,1) -- (-0.13,0.07);
			\draw [->] (-2,-1) -- (-0.13,-0.07);
			
			\path [draw=black, fill=white] (0,0) circle (1.5mm);
			\path [draw=black, fill=white] (-2,1) circle (1.5mm);
			\path [draw=black, fill=white] (2,1) circle (1.5mm);
			\path [draw=black, fill=white] (-2,-1) circle (1.5mm);
			\path [draw=black, fill=white] (2,-1) circle (1.5mm);
			
			\coordinate [label=135:$u$] (1) at (-2,1);
			\coordinate [label=-135:$u'$] (2) at (-2,-1);
			\coordinate [label=45:$v$] (3) at (2,1);
			\coordinate [label=-45:$v'$] (4) at (2,-1);
			\coordinate [label=above:$w_1$] (5) at (0,0.05);
		}
		\caption{\small Путь через первую промежуточную вершину}
	\end{figure}

	Пусть можно дойти от $u$ до $v$ по ребру. Рассмотрим первую промежуточную вершину $w_1$ и сравним путь через неё с длиной ребра, потом рассмотрим другую пару вершин $u'$ до $v'$ и сравним длину ребра между ними с путем через эту же промежуточную вершину $w_1$. Когда все пары вершин и ребра между ними будут рассмотрены, берем следующую промежуточную вершину и сравниваем длину пути с её использованием с длиной, рассмотренной до этого (без её использования). На каждом шаге в множество промежуточных вершин добавляется по одной новой вершине. Тем самым рассматриваются все более длинные пути.
	\begin{figure}[H]
		\centering
		\tikz{
			\draw [->] (-2,1) -- (-0.63,0.07);
			\draw [->] (-0.5,0) -- (0.37,0);
			\draw [->] (0.5,0) -- (1,0.3);
			\draw [dashed] (1,0.3) -- (1.3,0.65);
			\draw [->] (1.3,0.65) -- (1.43,0.865);
			
			\path [draw=black, fill=white] (-2,1) circle (1.5mm);
			\path [draw=black, fill=white] (-0.5,0) circle (1.5mm);
			\path [draw=black, fill=white] (0.5,0) circle (1.5mm);
			\path [draw=black, fill=white] (1.5,1) circle (1.5mm);
			
			\coordinate [label=135:$u$] (1) at (-2,1);
			\coordinate [label=45:$v$] (2) at (1.5,1);
			\coordinate [label=above:$u'$] (3) at (-0.5,0.1);
			\coordinate [label=above:$v'$] (4) at (0.5,0.1);
		}
		\caption{\small Дальнейший путь}
	\end{figure}
		
	\begin{lemma}
		\timestamp{54:57}
		На $k$-ом шаге основного цикла пометки алгоритма Флойда имеют следующий смысл: это кратчайшие пути на множестве путей, у которых в качестве промежуточных вершин используются вершины с первыми k номерами: $w_1, w_2, \ldots , w_k$ (это упорядочивание соответствует тому, в каком порядке мы берем вершины при прохождении цикла).
	\end{lemma}	
		
	\begin{exercise}
		Справедливость леммы и корректность алгоритма доказать самостоятельно.
	\end{exercise}

	\begin{note}
		До сих пор мы говорили о нахождении путей, но на самом деле мы находили не пути, а их длины. Исправить алгоритмы, чтобы они находили еще и сами пути, нетрудно. Давайте подкорректируем алгоритм Дейкстры, чтобы находить не только длины кратчайших путей, но и сами пути. 
		
		На самом деле, запоминать пути не обязательно, потому что кратчайшие пути образуют дерево кратчайших путей (так как цикл образоваться не может, иначе какой же это кратчайший путь, если мы по нему будем ходить по кругу). 
		
		Для того, чтобы сохранить дерево, достаточно помнить предыдущую вершину, то есть для каждой вершины нужно помнить, как мы в нее попали. Давайте введем еще одну пометку~--- $\B{v}$.
		
		\timestamp{58:41}
		\begin{algorithm}[H]
			\caption{Алгоритм Дейкстры}
			\label{alg:deyk2}
			\begin{algorithmic}[1]
				\State Инициализация:
				\ForAll{$v \in V$}
				\State $\D{v} := \A{s}{v}$
				\State $\B{v} := s$
				\EndFor
				\State $V'$~--- множество обработанных вершин, то есть тех, до которых расстояние уже найдено
				\State $V/V'$~--- множество необработанных вершин
				\State $\B{v}$~--- имя предыдущей вершины.
				\State $V' = \{s\}$
				\Statex
				\State Основной цикл:
				\While{$V/V' \ne 0$}
				\State Найти вершину с минимальной пометкой, пусть это $v$
				\State $V' := V' \bigcup \{v\}$
				\ForAll{$w \in V$}
				\If{$\D{w} + \A{v}{w} <  \D{w}$}
				\State $\D{w} := \D{w} + \A{v}{w}$
				\State $\B{w} := v$
				\Comment{Если $\D{w}$ меньше, то оно и останется}
				\EndIf
				\EndFor
				\EndWhile
			\end{algorithmic}
		\end{algorithm}
	\end{note}
	
\end{document}
